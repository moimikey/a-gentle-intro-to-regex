<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>reveal.js - The HTML Presentation Framework</title>
    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <style>
      img {
        box-shadow: none !important;
        border: 0 !important;
        background: none !important
      }

      .slide2 .hljs span.hljs-regexp { color: #FFF }
      .slide2 .hljs span.hljs-comment { color: #7F9F7F }
      .slide2 .hljs,
      .slide2 .hljs span { color: #333 }


      .slide3 .hljs span.hljs-regexp { color: #333 }
      .slide3 .hljs,
      .slide3 .hljs span { color: #FFF }
      .slide3 .hljs span.hljs-string { color: #FF4639 }
/*
      .slide3 .hljs span.hljs-something { color: red !important }
      .slide3 .hljs,
      .slide3 .hljs span { color: #666 }
*//*
      .slide3 .hljs span.hljs-something { color: red !important }
      .slide3 .hljs,
      .slide3 .hljs span { color: #666 }
*//*
      .slide3 .hljs span.hljs-something { color: red !important }
      .slide3 .hljs,
      .slide3 .hljs span { color: #666 }
*/
    </style>
  </head>
  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="about" data-background="#FFF">
          <h2>Regex Party 2k15</h2>
          <p class="fragment">My name is <span class="fragment roll-in">Michael</span></p>
          <p class="fragment">I'm <span class="fragment roll-in">moimikey</span> on <span class="fragment roll-in">GitHub</span>/<span class="fragment roll-in">NPM</span>/<span class="fragment roll-in">Twitter</span></p>
          <p class="fragment">I'm a <span class="fragment roll-in">Regular Expression</span> <span class="fragment grow">enthusiast</span></p>

          <aside class="notes">
            <p>I'd like to start by saying Hello, my name is Michael. My handle
               is `moimikey`. I use that on about everything. Most regularly,
               GitHub, NPM and Twitter.
            </p>
            <p>
               I like to say that I'm an enthusiast of Regular Expression. I would
               not necessarily call myself an expert, although I've been using
               it for over a decade now, there are parts of it that I've failed
               to memorize, but I've got my notes so we'll be fine. This is of
               course not to deter you from learning. I'm just very lazy.
            </p>
          </aside>
        </section>

        <section data-state"" data-background="#FFF">
          <h2>Thanks!</h2>
          <img src="images/sumi.jpg">
          <aside class="notes">
            <p>
              Big thanks to SUM Innovation for letting us occupy the space for
              this talk.
            </p>
          </aside>
        </section>

        <section data-state="regular-expression">
          <h3>Regular Expression</h3>
          <ul>
            <li class="fragment">Validate</li>
            <li class="fragment">Route Matching</li>
            <li class="fragment">Search &amp; Replace (substitution)</li>
            <li class="fragment">Parse</li>
          </ul>
          <aside class="notes">
            <p>please raise your hand if you know what regular expression is conceptionally?</p>
            <p>keep your hand up if you use regular expression, regularly?</p>
          </aside>
        </section>

        <section data-state="">
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = ""; // I AM STRING!
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop() // riiiiiiiiight...
  >
          </code></pre>
          <aside class="notes">
            <p>
              now keep your hand up if you can tell me what this would loosely attempt to match?
              it's not the most obvious. those with trained eyes may see it.
            </p>
          </aside>
        </section>

        <section data-state="">
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop()
  > "dQw4w9WgXcQ" // O RLY?
          </code></pre>
          <aside class="notes">
            <p>How about now?</p>
            <p>
              what you're seeing is not completely regular expression, but a little bit of JavaScript
              that is trying to `match` a pattern in a string (url). The `pop` at the end assumes that the
              `match` function is going to return an array which we'll understand a little bit later. the
              `pop` method comes for free with arrays, so lets just return the last item on the array.
            </p>
            <p>this last item, happens to be the YouTube ID.</p>
          </aside>
        </section>

        <section data-state="">
          <h3>Why?</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop()
  > "dQw4w9WgXcQ" // YA RLY.
          </code></pre>
          <aside class="notes">
            <p>But why?</p>
            <p>Lets first focus on the best part.</p>
          </aside>
        </section>

        <section data-state="slide2">
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop() // THE BEST!
  >
          </code></pre>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
            /.+:\/\/.+\/.+v?=(\w+)/
          </code></pre>
          <aside class="notes">
            Now what if we took this Regular Expression and split it up into smaller easier
            to read chunks...
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ 
  .+     ≈ 
  :\/\/  ≈ 
  .+     ≈
  \/     ≈ 
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp
  .+     ≈ 
  :\/\/  ≈ 
  .+     ≈
  \/     ≈ 
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp    
  .+     ≈ 1 or more characters
  :\/\/  ≈ 
  .+     ≈
  \/     ≈ 
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>   

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp    
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈
  \/     ≈ 
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>        

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp  
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈ 1 or more characters
  \/     ≈ 
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp  
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈ 1 or more characters
  \/     ≈ 1 forward slash
  .+v?=  ≈ 
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp  
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈ 1 or more characters
  \/     ≈ 1 forward slash
  .+v?=  ≈ 1 or more chars, opt. with a leading `v` &amp; "=" char
  (\w+)  ≈ 
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp  
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈ 1 or more characters
  \/     ≈ 1 forward slash
  .+v?=  ≈ 1 or more chars, opt. with a leading `v` &amp; "=" char
  (\w+)  ≈ Group capture 1 or more alphanumeric characters
  /      ≈ 


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ Like "" for String, [] for Array, // is for RegExp  
  .+     ≈ 1 or more characters
  :\/\/  ≈ 1 colon &amp; 2 forward slashes
  .+     ≈ 1 or more characters
  \/     ≈ 1 forward slash
  .+v?=  ≈ 1 or more chars, opt. with a leading `v` &amp; "=" char
  (\w+)  ≈ Group capture 1 or more alphanumeric characters
  /      ≈ Close our regular expression


          </code></pre>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ 
  .+     ≈ https       // match as many single characters as possible
  :\/\/  ≈ ://         // but stop at a colon, forward slash, slash
  .+     ≈ youtube.com // match as many single chars as possible
  \/     ≈ /           // but stop as a forward slash.
  .+v?=  ≈ watch?v=    // match as many single chars; stop before `=`
  (\w+)  ≈ dQw4w9WgXcQ // match a word, digits, or whitespace
  /      ≈ 

  https://youtube.com/watch?v=dQw4w9WgXcQ
          </code></pre>
          <aside class="notes">
            <p>
              If we put these into context however...
            </p>

            <p>
              <ul>
                <li>
                  this could potentially match ANY part of the string (imagining that it was a
                  paragraph containing a URL, or multiple instances of this URL. within the string,
                  we capture `https` because it's the FIRST thing we're trying to match; this
                  first matcher wants ANY number of characters, but we've indirectly told it to
                  half at a colon slash slash, because URLs have colon slash slash. Technically,
                  this could match `http` or `https`, or even `ftp`. we're loosely matching that
                  we have any number of characters except new lines all the way up until our next
                  matcher pointer hits the colon. Now, a more efficient and complex regular expression
                  would go the distance with this, and try to match it match ONLY http, or ONLY https,
                  for this, we don't care about the protocol, but we're assuming that if something has
                  a bit of text with a leading colon slash slash? it's probably a URL.
                </li>
                <li>
                  what comes after the slash in the URL will come the actual domain. similar to us
                  matching any characters with https, we can then assume that anything after a
                  prototocol, a colon slash slash, would most likely be a domain.
                </li>
                <li>
                  Since domains do not have slashes in them, then we can also assume that this URL
                  will have a protocol, a colon slash slash, a domain, and is delimited by a forward
                  slash, which indicates that we're at the root of that domain, or perhaps instead
                  of just a slash, slash index.html. in this case, for a YouTube URL, it's simply
                  just a slash.
                </li>
                <li>
                  We'll then capture one or more characters, regardless of what it is, except for white
                  space of course, and stop at `v` character. you'll notice though after the `v` character
                  there is a question mark. this is one of various types of character groupings. the
                  question mark considers the preceding matcher as "lazy." an easier way to think about
                  it, is that it's optional. so we might not even care if the `v` is there or not.
                </li>
                <li>
                  Last but not least, the part of the URL that matters, the YouTube ID. if you notice,
                  the part of the regular expression that we actually WANT, is what's encapsulated in
                  parenthesis. This matched grouping is what our the array our regex returns is. It's
                  within this, that we can actually match multiple parts of a regular expression.
                </li>
                <li></li>
              </ul>
            </p>

          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  /      ≈ 
  .+     ≈ https
  :\/\/  ≈ ://
  .+     ≈ youtube.com
  \/     ≈ /
  .+v?=  ≈ watch?v=
  (\w+)  ≈ dQw4w9WgXcQ // PARENTHESIS INDICATES A CAPTURE GROUP!
  /      ≈ 

  ['https://youtube.com/watch?v=dQw4w9WgXcQ', // index 0
   'dQw4w9WgXcQ']                             // index 1
          </code></pre>
          <aside class="notes">
            <p>
              We'll get into the immediate characters that we're dealing with here,
              but first...
            </p>
            <p>
              to match an string, or part of a string. Since we're using this
              particular YouTube URL, our Regular Expression is ensuring that
              it will match at particular string, based 
              type of URL, the only thing that is subject to change is the
              ID number, which explains why we're wanting to capture it. We
              can utilize other Regular Expression patterns though to ensure
              that what we're matching is indeed that particular kind of YouTube
              URL. We're trying presumptuously matching.
            </p>

            <p>
              You'll start to notice that Regular Expression is genuinely
              meant to match whatever string its given. In this case, when
              we try to match things that aren't exact, we supplement them
              with special characters.
            </p>

            <p>
            raise your hand if you know what being greedy is. a nicer way to verbalize it might be,
            over-indulgent by way of self-yinterest. the regular expression engine is very greedy.
            you'll ask for a particular pattern, but regex doesn't really know when to do. he'll
            keep over indulging unless you control him.
            </p>

            <p>the greediness of your regular expression will affect how qualifiers for 'zero or more' (*)
            or 'one or more' (+) behave. by default, they're quite greedy. they're quite immature, so
            we'll need to put them in their place so they aren't being so greedy we can just tack on
            a magical question mark (?). it's a leash for these greedy qualifiers:</p>
          </aside>
        </section>

<!-- outside regex, talk about the JS -->

        <section data-state="slide3">
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop()
  >
          </code></pre>
          <aside class="notes">
            at first glance, it's hard to see any disambiguation. if we look at a little closer, we can find some
            things that stand out:
          </aside>
        </section>

        <section data-state="slide7">
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/).pop()
  > "dQw4w9WgXcQ"
          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h3>&nbsp;</h3>
          <pre><code class="js">
  var url = "https://youtube.com/watch?v=dQw4w9WgXcQ";
  url.match(/.+:\/\/.+\/.+v?=(\w+)/)
  > ["https://youtube.com/watch?v=dQw4w9WgXcQ", "dQw4w9WgXcQ"]
          </code></pre>
        </section> 

        <section>
          <img src="images/modifiers.jpg">
        </section>

        <section>
          <h2>The Basics</h2>
          <pre><code class="js">
  .        matches ANY character, EXCEPT a line breaks. equiv to [^\n\r]
  \s\S     matches ANY character, INCLUDING line breaks. equiv to [^]
  \w       matches ALPHANUMERIC and UNDERSCORE. equiv to [A-Za-z0-9_]
  \W       matches NON-ALPHANUMERIC or UNDERSCORE. equiv to [^A-Za-z0-9_]
  \d       matches NUMBERS aka DIGITS. equiv to [0-9]
  \D       matches NON-NUMBERS aka NON-DIGITS. equiv to [^0-9]
  \s       matches ANY WHITESPACE (spaces, tabs, line breaks)
  \S       matches ANY NON-WHITESPACE
  [abc]    matches ANY characters in-between the square brackets
  [^abc]   matches ALL EXCEPT characters in-between the square brackets
  [a-z]    matches a RANGE between two characters
          </code></pre>
        </section>

        <section>
          <h2>The Ugly</h2>
          <pre><code class="js">
  /(?:youtube\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\?(?:\S*?&?v\=))|youtu\.be\/)([a-zA-Z0-9_-]{6,11})/g;
          </code></pre>
        </section>

        <section>
          <h2>When Not To Match</h2>
          <pre><code class="js">
  // a nice loose match for an email address, not too crazy...

  ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$.

  // try again then give up? this might be a little too arbitrary

  ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.(?:[A-Z]{2}|com|org|net|edu|gov|mil|
  biz|info|mobi|name|aero|asia|jobs|museum)$
          </code></pre>
        </section>

        <section>
          <h2>When Not To Match</h2>
          <pre><code class="js">
  // really? i mean...

  (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*
  |  "(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]
      |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])*")
@ (?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
  |  \[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
       (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
          (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
          |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])+)
     \])
          </code></pre>
        </section>

        <section>
          <h2>Matching HTML is OK, parsing? Not so much...</h2>
          <pre><code class="js">
  // great if you want to create a web scraping tool

  <table.+><thead><tr><td>(.+)&lt;\/td>&lt;\/tr>&lt;\/thead>\s*&lt;tbody>&lt;tr>&lt;td>(\S.*)&lt;\/td>&lt;\/tr>&lt;\/tbody>&lt;\/table>

          </code></pre>
        </section>

        <section>
          <h2>Afterword</h2>
          <ul>
            <li class="fragment">match only what's necessary</li>
            <li class="fragment">don't bother trying to parse HTML</li>
            <li class="fragment">your expression should be good at doing a single task</li>
            <li class="fragment">understand the differences between </li>
          </ul>

          <aside class="notes">
          <p>
            There are many other topics that can be covered with Regular Expression. This is just a small
            gist of what you can potentially do with Regular Expression, and the combinations of patterns
            are limitless.
          </p>
          <p>
            I want to stress that I don't believe there is a wrong way to write a Regular Expression, but
            there are ways to match more efficiently.
          </p>
          <p>
            Another last takeaway, 
          </p>
          <p>Raise your hand if you're unfamiliar with what Perl is?</p>
          <p>Perl is a really old programming language that had noteriety for
             being really good at string parsing and had a really powerful
             Regular Expression engine.
          </p>
          </aside>
        </section>

        <section data-state="intro" data-background="#FFF">
          <img src="images/regular_expressions.png">
          <audio src="sound/regex.wav" class="regex"></audio>
          <audio src="sound/tarzan.mp3" class="tarzan"></audio>
          <aside class="notes">
          </aside>
        </section>

        <section>
          <h2>Ask Me Anything!</h2>
        </section>

        <section>
          <h2>Mingle! Come up to me! Say Hi! I'm Shy!</h2>
        </section>
        </div>
      </div>
      <script src="lib/js/head.min.js"></script>
      <script src="js/reveal.js"></script>
      <script>
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'fade', // none/fade/slide/convex/concave/zoom
      // Optional reveal.js plugins
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
      ]
      });
      Reveal.addEventListener('intro', function(evt) {
        var el = evt.target;
        var timer = setTimeout(function() {
          var tarzan = setTimeout(function() {
            el.getElementsByClassName('tarzan')[0].play()
            clearTimeout(tarzan);
          }, 18000);
          el.getElementsByClassName('regex')[0].play()
          clearTimeout(timer);
        }, 10000);
      });
      </script>
    </body>
  </html>


<!--
awesome devtools, regex section http://goo.gl/zwrJ9h
my github:   

-->
